@begin[ref=index](section)
   @title(Overview)
   @c(material-reconstruction) is a tool which helps to restore 2D and 3D images
   according to their two-point and lineal-path correlation function using the
   algorithm called simulated annealing.

   According to Salvatore Torquato's book "Random Heterogeneous Materials",
   two-point correlation function is defined as follows:
   @begin(quote)
      The two-point or autocorrelation function S₂(r) = S₂¹(r) for statistically
   homogeneous media can be obtained by randomly tossing line segments of length
   r with a specified orientation [into the image] and counting the fraction of
   times the end points fall in phase 1.
   @end(quote)
   A definition of lineal-path function is similar:
   @begin(quote)
      The lineal-path function L₂(r) = L₂¹(r) for statistically homogeneous
   media can be obtained by randomly tossing line segments of length r with a
   specified orientation [into the image] and counting the fraction of times a
   whole segment falls in phase 1.
   @end(quote)

   The term "phase" means just a value of a pixel in an image. This library
   works with two-phase images which means its pixels can have a value @c(0) or
   @c(1).
@end(section)

@begin(section)
   @title(Dependencies)
   This library has few dependencies from the "C world":
   @begin(list)
      @item(A C compiler, like gcc or clang)
      @item(OpenCL)
      @item(FFTW3 with double precision)
   @end(list)
@end(section)

@begin(section)
   @title(Example)
   The following example takes an original image (a slice of @b(FIXME: ceramic))
   and an initial approximation and reconstructs the original. Dimensions of the
   original image are 300x300 pixels. The code below was used to run a
   reconstruction. The value of @c(steps) argument was @c(3000000).
   @begin[lang=lisp](code)
(defpackage annealing-test
  (:use #:cl #:recon)
  (:import-from #:alexandria #:curry)
  (:export #:test-annealing))
(in-package :annealing-test)

(defun read-image (name dimensions)
  "Read a binary file into an array of octets."
  (let* ((array (make-array dimensions :element-type 'bit))
         (displaced (make-array (reduce #'* dimensions)
                                :element-type 'bit
                                :displaced-to array
                                :displaced-index-offset 0)))
    (with-open-file (input name :element-type '(signed-byte 8))
      (read-sequence displaced input))
    array))

(defun make-modifier ()
  "Create a modifier which will sample the pixel at the boundary
between phases (zeros and ones) and change the value of the pixel to
the opposite."
  (make-instance 'batch-modifier
                 :modifier (make-instance 'flipper
                                          :sampler (make-instance 'interface-sampler))))

(defun test-annealing (original initial steps &key dimensions (t0 1d-5))
  "Run simulation of annealing for STEPS steps. INITIAL is the name of a
file with initial approximation of ORIGINAL. ORIGINAL and INITIAL are
file names of images with dimensions stored in the list DIMENSIONS in raw
format. T0 is initial temperature of the system."
  ;; Load images
  (let ((original-array (read-image original dimensions))
        (initial-array  (read-image initial  dimensions)))
    ;; Create GPU context
    (with-gpu-context (ctx)
      ;; Upload images to GPU
      (with-images ((image1 initial-array  image-s2 :context ctx)
                    (image2 original-array image-s2 :context ctx))
        ;; Create proximeter — an object which measures a distance
        ;; between two images according to two-point correlation
        ;; function.
        (with-proximeter (proximeter image1 image2)
          (let ((cost-state (make-instance 'cost-state
                                           :proximeter proximeter
                                           :image-x image1
                                           :image-y image2)) ; Used in calculation of cost function
                (cooldown   (aarts-korst-cooldown :n 10000 :alpha 0.01d0)) ; Create cooldown schedule
                (modifier   (make-modifier))) ; Create a modifier
            ;; RUN-ANNEALING is a helper function which calls ANNEALING-STEP STEPS times.
            (run-annealing image1 image2 t0 steps
                           :cost     (alexandria:curry #'cost cost-state)
                           :cooldown cooldown
                           :modifier modifier)))
        ;; Return the resulting bit array
        (image-array image1)))))
   @end(code)

   The original image: @image[src=original.png]()
   The initial approximation: @image[src=init.png]()
   The reconstruction: @image[src=reconstruction.png]()
@end(section)

@begin(section)
   @title(API)
   @u(Conditions)
   @cl:with-package[name="material-reconstruction"](
      @cl:doc(condition recon-error)
   )

   @u(GPU context)
   @cl:with-package[name="material-reconstruction"](
      @cl:doc(struct gpu-context)
      @cl:doc(function create-gpu-context)
      @cl:doc(function destroy-gpu-context)
      @cl:doc(macro with-gpu-context)
   )

   @u(Images)
   @cl:with-package[name="material-reconstruction"](
      @cl:doc(class image)
      @cl:doc(class image-l2)
      @cl:doc(class image-s2)
      @cl:doc(class image-all)
      @cl:doc(function create-image)
      @cl:doc(generic destroy-image)
      @cl:doc(function image-pixel)
      @cl:doc(macro with-image)
      @cl:doc(macro with-images)
   )

   @u(Proximeter)
   @cl:with-package[name="material-reconstruction"](
      @cl:doc(struct proximeter)
      @cl:doc(function create-proximeter)
      @cl:doc(function destroy-proximeter)
      @cl:doc(function proximity)
      @cl:doc(macro with-proximeter)
   )

   @u(Modifiers and samplers)
   @cl:with-package[name="material-reconstruction"](
      @cl:doc(class modifier)
      @cl:doc(class sampler)
      @cl:doc(class flipper)
      @cl:doc(class swapper)
      @cl:doc(class batch-modifier)
      @cl:doc(class interface-sampler)
      @cl:doc(class uniform-sampler)
   )

   @u(Cooldown schedules)
   @cl:with-package[name="material-reconstruction"](
      @cl:doc(function exponential-cooldown)
      @cl:doc(function aarts-korst-cooldown)
   )

   @u(Initialization)
   @cl:with-package[name="material-reconstruction"](
      @cl:doc(function initialize-random)
   )

   @u(Cost function and cost state)
   @cl:with-package[name="material-reconstruction"](
      @cl:doc(class cost-state)
      @cl:doc(function cost)
   )

   @u(Simulated annealing)
   @cl:with-package[name="material-reconstruction"](
      @cl:doc(function annealing-step)
      @cl:doc(function run-annealing)
   )

@end(section)

(in-package :material-reconstruction)

(defun lua-for% (next state control thunk)
  (declare (type function next thunk))
  (multiple-value-bind (next-control value)
      (funcall next state control)
    (when next-control
      (funcall thunk next-control value)
      (lua-for% next state next-control thunk))))

(defmacro lua-for ((key value form) &body body)
  "Iterate through iterator constructed with FORM"
  (alexandria:with-gensyms (function state control)
    `(multiple-value-bind (,function ,state ,control)
         ,form
       (lua-for% ,function ,state ,control
                  (lambda (,key ,value)
                    ,@body)))))

(defun run-next (state control)
  (declare (optimize (speed 3))
           (type alexandria:non-negative-fixnum control))
  (destructuring-bind (x . array) state
    (declare (type bit x)
             (type (simple-array bit (*)) array))
    (let ((start (position x array :start control)))
      (when start
        (let ((stop (or (position (- 1 x) array :start (1+ start))
                        (length array))))
          (values stop (- stop start)))))))
          
(defun count-runs (array x)
  "Return iterator which counts runs of X in bit array ARRAY."
  (values #'run-next (cons x array) 0))

(defun icount-next (state control)
  (declare (optimize (speed 3))
           (type fixnum state control))
  (if (< control state)
      (values (1+ control) control)))

(defun icount (stop &key (start 0))
  "Return iterator which counts from START to STOP"
  (values #'icount-next stop start))

(defun enumerate-next (state control)
  (declare (optimize (speed 3))
           (type fixnum control))
  (let* ((control (1+ control))
         (elt (nth control state)))
    (if elt (values control elt))))

(defun enumerate (list)
  "Return interator which enumerates all elements of LIST, starting
with 0."
  (values #'enumerate-next list -1))

(defun iproduct% (fn1 state1 control1 fn2 state2 control2)
  (declare (optimize (speed 3))
           (type function fn1 fn2))
  (let ((initial-control1 control1)
        value2)
    (labels ((next% (state control)
               (declare (ignore state control))
               (when (eql control1 initial-control1)
                 (setf (values control2 value2)
                       (funcall fn2 state2 control2)))
               (when (not control2)
                 (return-from next% nil))
               (multiple-value-bind (control1% value1)
                   (funcall fn1 state1 control1)
                 (cond
                   (control1%
                    (setq control1 control1%)
                    (values
                     t (cons value1 value2)))
                   (t
                    (setq control1 initial-control1)
                    (next% nil nil))))))
      #'next%)))

(defmacro iproduct (iter-form-1 iter-form-2)
  "Iterate through a product of spaces generated by iterators
ITER-FORM-1 and ITER-FORM-2"
  `(values (multiple-value-call #'iproduct% ,iter-form-1 ,iter-form-2) nil nil))

(defun imap-next (state control)
  (declare (optimize (speed 3)))
  (destructuring-bind (map-fn next-fn state) state
    (declare (type function map-fn next-fn))
    (multiple-value-bind (control value)
        (funcall next-fn state control)
      (when control
        (values control (funcall map-fn value))))))

(defun imap% (map-fn next-fn state control)
  (values #'imap-next (list map-fn next-fn state) control))

(defmacro imap (function iter-form)
  "Return an iterator which applies FUNCTION to elements of iterator
ITER-FORM."
  `(multiple-value-call #'imap% ,function ,iter-form))

(defun slices-2d (array axis)
  "Get all slices in a two-dimensional array ARRAY along axis AXIS."
  (declare (type bit axis)
           (optimize (speed 3)))
  (let ((nslices (array-dimension array (- 1 axis))))
    (imap (lambda (x)
            (slice array
                   (if (zerop axis)
                       (list t x)
                       (list x t))))
          (icount nslices))))

(defun slices-3d (array axis)
  "Get all slices in a three-dimensional array ARRAY along axis AXIS."
  (declare (type (integer 0 2) axis)
           (type (simple-array * (* * *)) array)
           (optimize (speed 3)))
  (let ((slicers
          (macrolet ((gen-slicer (idx1 idx2 form)
                       (let ((arg (gensym)))
                         `(lambda (,arg)
                            (destructuring-bind (,idx1 . ,idx2) ,arg
                              (slice array ,form))))))
            (list
             (gen-slicer c1 c2 (list t c2 c1))
             (gen-slicer c1 c2 (list c2 t c1))
             (gen-slicer c1 c2 (list c2 c1 t))))))
    (destructuring-bind (d1 d2 d3)
        (array-dimensions array)
    (imap (nth axis slicers)
          (cond
            ((= axis 0)
             (iproduct (icount d3)
                       (icount d2)))
            ((= axis 1)
             (iproduct (icount d3)
                       (icount d1)))
            ((= axis 2)
             (iproduct (icount d2)
                       (icount d1))))))))

(defun slices (array axis)
  (let ((ndims (length (array-dimensions array))))
    (ecase ndims
      (2 (slices-2d array axis))
      (3 (slices-3d array axis)))))
